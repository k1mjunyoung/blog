<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[RSS Feed of 🪐]]></title><description><![CDATA[안녕하세요. 주니어 개발자 김준영입니다.]]></description><link>https://blog.kimjunyoung.com</link><generator>GatsbyJS</generator><lastBuildDate>Tue, 19 Dec 2023 07:30:04 GMT</lastBuildDate><item><title><![CDATA[🐟 객체는 붕어빵이 아닙니다]]></title><description><![CDATA[…]]></description><link>https://blog.kimjunyoung.com/oop/</link><guid isPermaLink="false">https://blog.kimjunyoung.com/oop/</guid><pubDate>Thu, 30 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;객체지향이란&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;객체끼리는 서로 &lt;strong&gt;공존&lt;/strong&gt;하는 관계&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;현실세계에서는 &lt;strong&gt;단방향&lt;/strong&gt;으로 접근&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;사람 ➡️ 자동차: 단지 도구의 역할&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;객체지향의 세계에서는 &lt;strong&gt;양방향&lt;/strong&gt;으로 접근(&lt;strong&gt;요청 ↔️ 응답&lt;/strong&gt;)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;사람 ➡️ 자동차: 엑셀 밟기 요청
자동차 ➡️ 사람: 가속 응답(기름 소모)&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;객체지향 프로그래밍&lt;/h2&gt;
&lt;h3&gt;책임주도설계&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;객체는 &lt;strong&gt;책임&lt;/strong&gt;을 나눠갖도록 설계해야 한다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/1998/post/058a8fdc-8139-491c-9ca4-43b773476ebe/image.png&quot; alt=&quot;책임주도설계&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;사람(객체)의 책임: 주유 행동, 가속 요청&lt;/li&gt;
&lt;li&gt;자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답&lt;/li&gt;
&lt;li&gt;주유소(객체)의 책임: 사람으로부터 주유 요청 시 응답&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;즉, 책임주도 설계란 각 객체에게 책임을 부여해서 적절하게 상호작용할 수 있도록 설계하는 것.&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;역할과 구현&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;💡 자동차 객체를 버스에 맞춰 구현했는데 트럭이 필요하다면?&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;역할(큰 틀)을 중심으로 구현&lt;/strong&gt;
자동차(역할) &gt; 굴러감(책임) &gt; 승용차, 트럭, 버스(구현)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;text&quot;&gt;&lt;pre class=&quot;language-text&quot;&gt;&lt;code class=&quot;language-text&quot;&gt;승용차, 트럭, 버스의 공통적인 역할: 엑셀, 전진, 후진, 기름…&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;추후에 제한사항이 생길 수 있으므로 공통적인 역할 먼저, 세부적인 건 나중에 구현&lt;/strong&gt;
원하는 기능만을 통해서 자율성을 가질 수 있도록 객체에게 맞는 책임을 잘 부여해야 함.
잘 만들어진 객체지향은 신뢰할 수 있음.&lt;/p&gt;
&lt;h3&gt;객체지향 프로그래밍의 4가지 특징&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 추상화&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 캡슐화&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;한 부분이 망가져도 전체적인 서비스에는 영향이 없게끔 결합도는 낮게 설계해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 상속&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. 다형성&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;메서드 오버라이딩: 상위 → 하위 재정의&lt;/li&gt;
&lt;li&gt;메서드 오버로딩: 같은 이름의 메서드 → 상황에 따라 다른 기능&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;객체지향 설계원칙, SOLID&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;1. 단일 책임 원칙(SRP, Single Responsibility Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 클래스는 하나의 책임만을 가져야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;2. 개방-폐쇄 원칙(OCP, Open-closed Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.&lt;/li&gt;
&lt;li&gt;기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.&lt;/li&gt;
&lt;li&gt;상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입의 프로그램은 정상 작동해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;하나의 인터페이스보다 여러 개의 인터페이스로 분리하는 것이 좋다.&lt;/li&gt;
&lt;li&gt;인터페이스는 사용자(클라이언트)를 기준으로 분리해야 한다.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;추상화가 아닌 구체화에 의존해서는 안된다.&lt;/li&gt;
&lt;li&gt;고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.&lt;/li&gt;
&lt;li&gt;저수준 모듈의 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[🔥 다이나믹하게 프로그래밍해보자]]></title><description><![CDATA[다이나믹 프로그래밍이란? 다이나믹 프로그래밍(Dynamic Programming, DP…]]></description><link>https://blog.kimjunyoung.com/dynamic-programming/</link><guid isPermaLink="false">https://blog.kimjunyoung.com/dynamic-programming/</guid><pubDate>Mon, 27 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;다이나믹 프로그래밍이란?&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;다이나믹 프로그래밍(Dynamic Programming, DP)&lt;/strong&gt;이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다.&lt;/p&gt;
&lt;h2&gt;📜 피보나치 수열과 분할 정복&lt;/h2&gt;
&lt;p&gt;피보나치 수열은 &lt;strong&gt;특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합&lt;/strong&gt;을 구해야 한다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;피보나치 수열 점화식: &lt;code class=&quot;language-text&quot;&gt;D[i] = D[i-1] + D[i-2]&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;피보나치 수열의 초기 값은 &lt;code class=&quot;language-text&quot;&gt;1&lt;/code&gt; 로 고정되므로 위 점화식에 적용하면 &lt;code class=&quot;language-text&quot;&gt;1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...&lt;/code&gt; 와 같이 나아갈 수 있다.
만약 단순 분할 정복 기법을 이용해 피보나치 수열을 푼다면 어떻게 될까?&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://velog.velcdn.com/images/1998/post/1392ab01-7f62-4f5b-87e5-30a623405193/image.png&quot; alt=&quot;출처: https://blog.naver.com/ndb796/221233570962&quot;&gt;&lt;/p&gt;
&lt;p&gt;단순 분할 정복으로 피보나치 수열의 15번째 값인 &lt;code class=&quot;language-text&quot;&gt;D[15]&lt;/code&gt; 를 구하려면 &lt;code class=&quot;language-text&quot;&gt;D[14]&lt;/code&gt; 와 &lt;code class=&quot;language-text&quot;&gt;D[13]&lt;/code&gt; 을 계산해야 하고, &lt;code class=&quot;language-text&quot;&gt;D[14]&lt;/code&gt; 를 구하려면 &lt;code class=&quot;language-text&quot;&gt;D[13]&lt;/code&gt; 과 &lt;code class=&quot;language-text&quot;&gt;D[12]&lt;/code&gt; 를 계산해야 한다.
이렇게 단순한 분할 정복 기법을 사용하면 이미 수행한 계산를 또 반복적으로 수행하기 때문에 &lt;strong&gt;굉장히!&lt;/strong&gt; 비효율적이게 된다.&lt;/p&gt;
&lt;p&gt;아래는 단순하게 피보나치 수열을 구하는 과정을 JAVA로 구현한 코드이다.&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;10&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위와 같이 &lt;code class=&quot;language-text&quot;&gt;fybo&lt;/code&gt; 메서드(함수)에 &lt;code class=&quot;language-text&quot;&gt;10&lt;/code&gt; 을 넣으면 피보나치 수열의 10번째 값인 &lt;code class=&quot;language-text&quot;&gt;55&lt;/code&gt; 가 잘 출력된다. &lt;strong&gt;만약 &lt;code class=&quot;language-text&quot;&gt;fybo&lt;/code&gt; 메서드에 &lt;code class=&quot;language-text&quot;&gt;50&lt;/code&gt; 을 넣으면 어떻게 될까?&lt;/strong&gt;
.
.
.
&lt;em&gt;아마 우주가 멸망할 때까지 CPU가 달궈지고 결국엔 실행되지 않을 것이다...&lt;/em&gt;😮&lt;/p&gt;
&lt;p&gt;이는 사실 당연한 결과로, 피보나치 수열이 1개만 증가해도 &lt;strong&gt;계산량은 2배로 늘어난다.&lt;/strong&gt; 위와 같은 방법으로 피보나치 수열의 50번째 값을 구하려면 2의 50제곱 즉, 1,000,000,000,000,000개가 넘는 계산량을 컴퓨터가 처리해야 한다는 것이다.&lt;/p&gt;
&lt;h2&gt;🔥 DP의 등장&lt;/h2&gt;
&lt;p&gt;다이나믹 프로그래밍은 다음의 두 가정 하에 사용할 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;큰 문제를 작은 문제로 나눌 수 있다.&lt;/li&gt;
&lt;li&gt;작은 문제에서 구한 정답이 그 문제를 포함하는 큰 문제에서도 동일하다.&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;쉽게 말해, 크고 어려운 문제를 잘게 나누어 해결한 뒤에 전체의 답을 구하는 방법이다. 다만 이 과정에서 분할 정복과 다른 점은 &lt;strong&gt;메모이제이션(Memoization)&lt;/strong&gt;이 사용된다는 것이다. &lt;u&gt;이미 계산한 결과는 배열에 저장함으로써&lt;/u&gt; 나중에 동일한 계산을 해야 할 때 배열에서 꺼내오기만 하면 된다.&lt;/p&gt;
&lt;h3&gt;📝 메모이제이션&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;메모이제이션(Memoization)&lt;/strong&gt;이란 동일한 계산을 반복해야 할 때 &lt;u&gt;이미 계산한 결과를 메모리(배열)에 저장&lt;/u&gt;해 두었다가 필요할 때 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;다이나믹 프로그래밍의 메모이제이션 기법을 활용하면 우주멸망을 막을 수 있다(?)&lt;/p&gt;
&lt;div class=&quot;gatsby-highlight&quot; data-language=&quot;java&quot;&gt;&lt;pre class=&quot;language-java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;token class-name&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; d &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token keyword&quot;&gt;int&lt;/span&gt; x&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x &lt;span class=&quot;token operator&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;d&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;!=&lt;/span&gt; &lt;span class=&quot;token number&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; d&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;token keyword&quot;&gt;return&lt;/span&gt; d&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;x&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;token operator&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;x&lt;span class=&quot;token operator&quot;&gt;-&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;token keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;token keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;token function&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token class-name&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;]&lt;/span&gt; args&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;token class-name&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;out&lt;span class=&quot;token punctuation&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token function&quot;&gt;fibo&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;token number&quot;&gt;30&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;token punctuation&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;token punctuation&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;위의 코드는 다이나믹 프로그래밍의 메모이제이션 기법을 활용해 작성한 JAVA 코드이다.&lt;/p&gt;
&lt;p&gt;이미 계산된 결과는 배열 &lt;code class=&quot;language-text&quot;&gt;d&lt;/code&gt; 에 저장되기 때문에 한 번 구한 값을 다시 계산하는 일은 없으므로 &lt;strong&gt;순식간에!&lt;/strong&gt; 피보나치 수열의 30번째 값이 구해지는 것을 볼 수 있다.(50번째 값은 매우 크기 때문에 오버플로우가 발생하여 음수값이 나온다. 알고 싶다면 &lt;code class=&quot;language-text&quot;&gt;int&lt;/code&gt; 타입 대신 &lt;code class=&quot;language-text&quot;&gt;long&lt;/code&gt; 타입을 사용하자)&lt;/p&gt;
&lt;h2&gt;마무리&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1463&quot;&gt;백준 1463번&lt;/a&gt;을 다이나믹하게 풀어보아요&lt;/p&gt;
&lt;h3&gt;ref&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.google.com/&quot; target=&quot;_blank&quot;&gt;[이것이 코딩테스트다] 저자, 나동빈님 블로그&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[🔎 클린코드 훑어보기]]></title><description><![CDATA[…]]></description><link>https://blog.kimjunyoung.com/clean-code/</link><guid isPermaLink="false">https://blog.kimjunyoung.com/clean-code/</guid><pubDate>Mon, 10 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;더러운 코드도 돌아는 간다. 하지만 코드가 깨끗하지 못하면 개발 조직은 기어간다. 매년 지저분한 코드로 수많은 시간과 상당한 자원이 낭비된다. 그래야 할 이유가 없다. 로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 코드를 읽어야 한다. 아주 많은 코드를. 그리고 코드를 읽으면서 그 코드의 무엇이 옳은지, 그른지 생각도 해야 한다. 좀 더 중요하게는 전문가로서 자신이 지니는 가치와 장인으로서 자기 작품(프로그램)에 대한 헌신을 돌아보게 된다. 코드를 읽고, 짜고 정리하는 과정에서 우리가 생각하는 방식을 묘사한 지식 기반을 얻는다.&lt;/p&gt;
&lt;h2&gt;1. 의도를 분명히 밝혀라&lt;/h2&gt;
&lt;p&gt;변수의 존재 이유, 기능, 사용법 등이 변수, 함수, 클래스명에 드러나야 한다. 의미를 함축하거나 독자가 사전지식을 갖고 있다고 가정하지 말자.&lt;/p&gt;
&lt;h2&gt;2. 그릇된 정보를 피하라&lt;/h2&gt;
&lt;p&gt;중의적으로 해석될 수 있는 이름을 지양하고 개발자에게는 특수한 의미를 가지는 단어를 변수명에 붙이지 말자. 또한 비슷해 보이는 명명에 주의하자&lt;/p&gt;
&lt;h2&gt;3. 의미 있게 구분하라&lt;/h2&gt;
&lt;p&gt;말이 안되는 단어, 숫자(a1, a2..)로 구분하는 것을 피하고 클래스 이름에 info, data와 같은 불용어를 붙이지 말자.&lt;/p&gt;
&lt;h2&gt;4. 발음하기 쉬운 이름을 사용하라&lt;/h2&gt;
&lt;h2&gt;5. 검색하기 쉬운 이름을 사용하라&lt;/h2&gt;
&lt;p&gt;상수는 static final과 같이 정의해서 사용하자. 변수 이름의 길이는 변수의 범위에 비례해서 길어진다.&lt;/p&gt;
&lt;h2&gt;6. 자신의 기억력을 자랑하지 마라&lt;/h2&gt;
&lt;p&gt;독자가 한번 더 생각해 변환해야 할 만한 변수명을 쓰지 말자. 똑똑한 프로그래머와 전문가 프로그래머를 나누는 기준은 &lt;strong&gt;명료함&lt;/strong&gt;이다.&lt;/p&gt;
&lt;h2&gt;7. 클래스 이름에 대해&lt;/h2&gt;
&lt;p&gt;동사 대신 명사 혹은 명사구를 사용하고 Manager, Processor, Data, Info와 같은 단어는 피하자.&lt;/p&gt;
&lt;h2&gt;8. 메서드 이름&lt;/h2&gt;
&lt;p&gt;동사 혹은 동사구를 사용하고 접근자, 변경자, 조건자는 get, set, is로 시작하자. 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고, 해당 생성자를 private로 선언하자.&lt;/p&gt;
&lt;h2&gt;9. 기발한 이름은 피하라&lt;/h2&gt;
&lt;p&gt;특정 문화에서만 사용되는 재미있는 이름보다 의도를 분명히 표현하는 이름을 사용하자.&lt;/p&gt;
&lt;h2&gt;10. 한 개념에 한 단어를 사용하라&lt;/h2&gt;
&lt;p&gt;추상적인 개념 하나에 단어 하나를 사용하자&lt;/p&gt;
&lt;h2&gt;11. 해법 영역(Solution Domain) 용어를 사용하자&lt;/h2&gt;
&lt;p&gt;개발자라면 당연히 알고 있을 JobQueue, AccountVisitor 등을 사용하지 않을 이유가 없다. 전산용어, 알고리즘 이름, 패턴 이름, 수학적 용어 등은 피하자.&lt;/p&gt;
&lt;h2&gt;12. 문제 영역(Problem Domain) 용어를 사용하자&lt;/h2&gt;
&lt;p&gt;적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하자.&lt;/p&gt;
&lt;h2&gt;13. 의미 있는 맥락을 추가하라&lt;/h2&gt;
&lt;p&gt;클래스, 함수, namespace 등으로 감싸서 맥락을 표현하라. 그래도 불분명하다면 접두어를 사용하자.&lt;/p&gt;</content:encoded></item></channel></rss>