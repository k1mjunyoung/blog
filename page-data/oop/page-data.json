{"componentChunkName":"component---src-templates-post-jsx","path":"/oop/","result":{"data":{"site":{"siteMetadata":{"title":"🪐"}},"markdownRemark":{"id":"126bdf0a-89db-59af-9b03-d0df58e5dc58","excerpt":"객체지향이란 객체끼리는 서로 공존하는 관계 현실세계에서는 단방향으로 접근 객체지향의 세계에서는 양방향으로 접근(요청 ↔️ 응답) 객체지향 프로그래밍 책임주도설계 객체는 책임을 나눠갖도록 설계해야 한다. 책임주도설계 사람(객체)의 책임: 주유 행동, 가속 요청 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답 주유소(객체)의 책임: 사람으로…","html":"<h2>객체지향이란</h2>\n<blockquote>\n<p>객체끼리는 서로 <strong>공존</strong>하는 관계</p>\n</blockquote>\n<ul>\n<li>\n<p>현실세계에서는 <strong>단방향</strong>으로 접근</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">사람 ➡️ 자동차: 단지 도구의 역할</code></pre></div>\n</li>\n<li>\n<p>객체지향의 세계에서는 <strong>양방향</strong>으로 접근(<strong>요청 ↔️ 응답</strong>)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">사람 ➡️ 자동차: 엑셀 밟기 요청\n자동차 ➡️ 사람: 가속 응답(기름 소모)</code></pre></div>\n</li>\n</ul>\n<h2>객체지향 프로그래밍</h2>\n<h3>책임주도설계</h3>\n<blockquote>\n<p>객체는 <strong>책임</strong>을 나눠갖도록 설계해야 한다.</p>\n</blockquote>\n<p><img src=\"https://velog.velcdn.com/images/1998/post/058a8fdc-8139-491c-9ca4-43b773476ebe/image.png\" alt=\"책임주도설계\"></p>\n<ul>\n<li>사람(객체)의 책임: 주유 행동, 가속 요청</li>\n<li>자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답</li>\n<li>주유소(객체)의 책임: 사람으로부터 주유 요청 시 응답</li>\n</ul>\n<p><strong>즉, 책임주도 설계란 각 객체에게 책임을 부여해서 적절하게 상호작용할 수 있도록 설계하는 것.</strong></p>\n<h3>역할과 구현</h3>\n<blockquote>\n<p>💡 자동차 객체를 버스에 맞춰 구현했는데 트럭이 필요하다면?</p>\n</blockquote>\n<p><strong>역할(큰 틀)을 중심으로 구현</strong>\n자동차(역할) > 굴러감(책임) > 승용차, 트럭, 버스(구현)</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">승용차, 트럭, 버스의 공통적인 역할: 엑셀, 전진, 후진, 기름…</code></pre></div>\n<p><strong>추후에 제한사항이 생길 수 있으므로 공통적인 역할 먼저, 세부적인 건 나중에 구현</strong>\n원하는 기능만을 통해서 자율성을 가질 수 있도록 객체에게 맞는 책임을 잘 부여해야 함.\n잘 만들어진 객체지향은 신뢰할 수 있음.</p>\n<h3>객체지향 프로그래밍의 4가지 특징</h3>\n<p><strong>1. 추상화</strong></p>\n<p><strong>2. 캡슐화</strong></p>\n<ul>\n<li>한 부분이 망가져도 전체적인 서비스에는 영향이 없게끔 결합도는 낮게 설계해야 한다.</li>\n</ul>\n<p><strong>3. 상속</strong></p>\n<p><strong>4. 다형성</strong></p>\n<ul>\n<li>메서드 오버라이딩: 상위 → 하위 재정의</li>\n<li>메서드 오버로딩: 같은 이름의 메서드 → 상황에 따라 다른 기능</li>\n</ul>\n<h3>객체지향 설계원칙, SOLID</h3>\n<p><strong>1. 단일 책임 원칙(SRP, Single Responsibility Principle)</strong></p>\n<ul>\n<li>하나의 클래스는 하나의 책임만을 가져야 한다.</li>\n</ul>\n<p><strong>2. 개방-폐쇄 원칙(OCP, Open-closed Principle)</strong></p>\n<ul>\n<li>소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.</li>\n<li>기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.</li>\n</ul>\n<p><strong>3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)</strong></p>\n<ul>\n<li>객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.</li>\n<li>상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입의 프로그램은 정상 작동해야 한다.</li>\n</ul>\n<p><strong>4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)</strong></p>\n<ul>\n<li>하나의 인터페이스보다 여러 개의 인터페이스로 분리하는 것이 좋다.</li>\n<li>인터페이스는 사용자(클라이언트)를 기준으로 분리해야 한다.</li>\n</ul>\n<p><strong>5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)</strong></p>\n<ul>\n<li>추상화가 아닌 구체화에 의존해서는 안된다.</li>\n<li>고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.</li>\n<li>저수준 모듈의 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.</li>\n</ul>","frontmatter":{"title":"🐟 객체는 붕어빵이 아닙니다","date":"November 30, 2023","update":"November 30, 2023","tags":["oop"],"series":null},"fields":{"slug":"/oop/","readingTime":{"minutes":4.295}}},"seriesList":{"edges":[{"node":{"id":"9c548896-5498-5cc6-8f2c-07cb3884d770","fields":{"slug":"/clean-code/"},"frontmatter":{"title":"🔎 클린코드 훑어보기"}}},{"node":{"id":"126bdf0a-89db-59af-9b03-d0df58e5dc58","fields":{"slug":"/oop/"},"frontmatter":{"title":"🐟 객체는 붕어빵이 아닙니다"}}}]},"previous":{"fields":{"slug":"/dynamic-programming/"},"frontmatter":{"title":"🔥 다이나믹하게 프로그래밍해보자"}},"next":null},"pageContext":{"id":"126bdf0a-89db-59af-9b03-d0df58e5dc58","series":null,"previousPostId":"bca57240-39f6-50d6-96f5-e7b663f81479","nextPostId":null}},"staticQueryHashes":[],"slicesMap":{}}