{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"모뎀 공인IP 할당 공유기 사설 네트워크 형성 사설IP 부여 라우터(L3, 개념적으로 게이트웨이) 역할 DHCP LAT 외부에서 내 컴퓨터로 접속? 외부 -> ISP -> 모뎀 -> 공유기(220.221.223.3:80 - 192.168.0.2:80 포트포워딩) -> PC(192.168.0.2:80) 허브와 스위치 허브 OSI L1 IP주소 할당하는 기능…","fields":{"slug":"/network/"},"frontmatter":{"date":"July 05, 2024","title":"외부에서 내 사설IP로 어떻게 접속할까?","tags":["network"]},"rawMarkdownBody":"\n```\nISP\n└──모뎀: 공인IP 할당\n    ├── PC(공인IP: 220.221.222.1)\n    ├── PC(공인IP: 220.221.222.2)\n    └── 공유기(공인IP: 220.221.222.3, 사설IP: 192.168.0.1)\n        ├── PC(사설IP: 192.168.0.2)\n        └── TV(사설IP: 192.168.0.3)\n```\n\n## 모뎀\n\n-   공인IP 할당\n\n## 공유기\n\n-   사설 네트워크 형성\n-   사설IP 부여\n-   라우터(L3, 개념적으로 게이트웨이) 역할\n-   DHCP\n-   LAT\n\n## 외부에서 내 컴퓨터로 접속?\n\n외부 -> ISP -> 모뎀 -> 공유기(220.221.223.3:80 - 192.168.0.2:80 포트포워딩) -> PC(192.168.0.2:80)\n\n## 허브와 스위치\n\n### 허브\n\n-   OSI L1\n-   IP주소 할당하는 기능 X\n-   연결된 모든 기기로 전송\n\n### 스위치\n\n-   OSI L2\n-   IP주소 할당하는 기능 X\n-   기기들의 MAC주소 저장\n-   브로드캐스트(모든 기기들에게 목적지가 당신인지 확인)"},{"excerpt":"마주한 이슈 JPA로 List를 받아와서 수정 후  하는 기존 로직에서 hibernate 로그가 수없이 뜨는 걸 발견, JPA가 데이터 수만큼 건별로 Update하기 때문 Bulk update 벌크 업데이트를 위해선  어노테이션을 사용해야 한다. SpringDataJPA가 해당 리포지토리 메소드가 SELECT문인지 UPDATE문인지 알아야 Return T…","fields":{"slug":"/jpa-bulk-update/"},"frontmatter":{"date":"March 29, 2024","title":"💪 JPA 대량 데이터 한번에 UPDATE하기","tags":["jpa"]},"rawMarkdownBody":"\n## 마주한 이슈\nJPA로 List를 받아와서 수정 후 `saveAll()` 하는 기존 로직에서 hibernate 로그가 수없이 뜨는 걸 발견, JPA가 데이터 수만큼 건별로 Update하기 때문\n\n```java\nList<Tbl080Block> findByRejectNum(String rejectNum);\n```\n\n## Bulk update\n\n벌크 업데이트를 위해선 `@Modifying` 어노테이션을 사용해야 한다.\n\n> SpringDataJPA가 해당 리포지토리 메소드가 SELECT문인지 UPDATE문인지 알아야 Return Type을 결정하는데, 아직은 내부적으로 Query만 보고 판단을 못해서, 명시를 해줘야 Return type을 결정하기 때문입니다.\n> \n\n```java\n@Modifying\n@Query(nativeQuery = true, value = \"UPDATE TBL_080_BLOCK SET EXP_DT = :nowDt WHERE REJECT_NUM = :rejectNum\")\nint updateExpDtByRejectNum(@Param(\"rejectNum\") String rejectNum, @Param(\"nowDt\")LocalDateTime nowDt);\n```\n\n### 사용 시 주의사항\n\n벌크 업데이트를 할 때, 주의사항이 있다.\n\n1차 캐시라고 불리는 **영속성 컨텍스트** 때문인데, **벌크 업데이트는 단일 업데이트와 다르게 영속성 컨텍스트에 있는 엔티티를 변경하지 않는다.**\n\n> 내부적인 동작은 아래와 같이 동작합니다.\n> \n> 1. 영속성 컨텍스트에 엔터티 2개를 추가 + 쓰기 지연 SQL 저장소에 INSERT문 저장\n> 2. 영속성 컨텍스트를 flush(JPQL 실행 때문) -> **쓰기 지연 SQL 저장소에만 UPDATE문 저장**\n> 3. 영속성 컨텍스트에서 엔터티 조회\n> 4. Update문이 적용되지 않은 값을 반환\n\n해결방법은 벌크 업데이트로 인해 변경된 값을 참조해야 한다면, 영속성 컨텍스트를 DB에 반영하고 영속성 컨텍스트를 비워야 한다. 그렇게 되면, 해당 값을 참조할 때 영속성 컨텍스트가 아니라 DB에 직접 접근하게 되어서 반영된(업데이트된) 값을 가져올 수 있다.\n\n`@Modifying` 의 `clearAutomatically` 옵션을 사용해야 한다.\n\n```java\n@Modifying(clearAutomatically = true)\n@Query(nativeQuery = true, value = \"UPDATE TBL_080_BLOCK SET EXP_DT = :nowDt WHERE REJECT_NUM = :rejectNum\")\nint updateExpDtByRejectNum(@Param(\"rejectNum\") String rejectNum, @Param(\"nowDt\")LocalDateTime nowDt);\n```\n\n### 트랜젝션?\n\n위와 같이 네이티브 쿼리를 적용하니 또 다른 에러가 발생했는데, Transaction 관련 에러였다.\n\n```bash\njavax.persistence.TransactionRequiredException:Executing an update/delete query \n```\n\n`@Transactional` 어노테이션을 붙이니 해결되었는데 트랜잭션에 대한 공부는 추후에..\n\n```java\n@Transactional\n@Modifying(clearAutomatically = true)\n@Query(nativeQuery = true, value = \"UPDATE TBL_080_BLOCK SET EXP_DT = :nowDt WHERE REJECT_NUM = :rejectNum\")\nint updateExpDtByRejectNum(@Param(\"rejectNum\") String rejectNum, @Param(\"nowDt\")LocalDateTime nowDt);\n```\n\n[참고] [https://jaehoney.tistory.com/151](https://jaehoney.tistory.com/151)"},{"excerpt":"Overview 인턴을 하던 회사에 첫 취업을 하고 UMS 개발 프로젝트를 맡게 되었다.   🧐 UMS란?\n  UMS(Unified Messaging System, 통합메세징시스템)란 기존에 개별적으로 서비스되던 음성사서함, 팩스사서함, 자동응답, e메일 시스템을 통합한 것으로 사업자는 시스템도입비용을 줄이고 가입자는 단말기의 종류에 상관없이 개인메세지를…","fields":{"slug":"/rabbitMQ/"},"frontmatter":{"date":"January 20, 2024","title":"💬 메세지 큐와 RabbitMQ","tags":["rabbitMQ"]},"rawMarkdownBody":"\n## Overview\n\n인턴을 하던 회사에 첫 취업을 하고 UMS 개발 프로젝트를 맡게 되었다.\n\n>   **🧐 UMS란?**<br>\n>   UMS(Unified Messaging System, 통합메세징시스템)란 기존에 개별적으로 서비스되던 음성사서함, 팩스사서함, 자동응답, e메일 시스템을 통합한 것으로 사업자는 시스템도입비용을 줄이고 가입자는 단말기의 종류에 상관없이 개인메세지를 관리할 수 있다.\n\n우리 회사에서는 UMS로 기업이 SMS, MMS, 카카오 알림톡, 대용량 이메일 등을 다양한 형태의 메세지를 하나의 플랫폼에서 편리하게 이용할 수 있도록 하는 것 같다.\n\n본격적으로 현재 팀에서 진행하고 있는 프로젝트에 대한 설명을 들으면서 RabbitMQ와 Redis를 사용하고 있었고, 이에 대해 공부해야겠다고 생각했다.\n\n## 💬 메세지 큐와 메세지 브로커\n\n모놀로식 아키텍쳐*(하나의 서비스 또는 애플리케이션이 하나의 거대한 아키텍처를 가지는 전통적인 아키텍처)* 시대에는 애플리케이션 구성요소가 긴밀하게 결합되어 있었다.\n\n즉, 직접 연결되어있었다. 간단한 판매 애플리케이션 내에서 결제 서비스와 재고 서비스가 통신해야 되는 경우 일반적으로 TCP 연결을 통해 직접 수행된다.\n\n하지만 이 경우에 몇가지 한계가 있었다.\n\n![직접 연결된 결제 서비스와 재고 서비스](checkout-to-inventory.png)\n\n결제시스템이 메세지를 보내자마자 다음 작업으로 넘어가기 전에 응답을 받아야 하는데, 최악의 경우에 재고 서비스가 다운되면 연결이 가능할 때까지 계속해서 시도한다는 것이다. 또는 한꺼번에 많은 결제가 발생하면 재고 서비스가 이를 따라잡지 못하고 전체 시스템이 정체될 수 있다. \n\n![메세지 큐](message-queue.png)\n\n이것이 바로 메세지 큐, 즉 메세지 브로커가 만들어진 이유이며 메세지 큐는 서로 통신해야 하는 두 서비스 사이에 미들웨어로 위치하게 된다. \n\n### 메세지 큐의 장점\n\n1. 분리(Decouple)\n    \n    메세지 큐를 사용하면 결제 시 큐에 메세지를 추가한 후, 즉시 다음 작업으로 이동할 수 있다. 그럼 다음 마찬가지로 재고 서비스가 준비되면 큐에서 메세지를 처리하고 즉시 그 다음 메세지를 처리할 수 있다. 따라서 메시지 큐로 인해 두 응용프로그램이 분리된다. \n    \n2. 확장성(Scalable)\n    \n    메세지 브로커는 확장성도 높일 수 있다. 한꺼번에 많은 결제가 발생하면 큐가 채워지기 시작하고 하나 이상의 메세지 소비 서비스(위 그림의 `Inventory` 서비스)가 큐에서 읽어 처리할 수 있다. 결제 서비스가 생성하는 작업량이 늘어나고 시스템 확장성이 향상된다. \n    \n3. 성능(Performent)\n    \n    메세지 큐의 또 다른 큰 장점은 큐 자체가 자체 시스템에 존재할 수 있다는 것이다. 따라서 이 경우에 웹 애플리케이션이 수행하는 작업 중 일부를 오프로드해서 전체 시스템의 성능을 향상시킬 수 있다.\n    \n\n## 🐇 RabbitMQ\n\nRabbitMQ는 AMQP(Advanced Message Queuing Protocol) 메세지 모델의 구현이다. 이 유형의 메세지 모델을 사용하면 생산자(메세지를 생성하는 서비스)는 결제 서비스가 된다. 메세지 큐는 교환소(Exchange)에서 생성되는데, 쉽게 우체국이라고 생각하면 된다. 교환소는 모든 메세지를 수신한 다음 주소 지정 방법에 따라 배포하는데, 교환소는 많은 큐(대기열)에 연결될 수 있다. 예를 들어 아래 그림처럼 재고 서비스와 배송 서비스 두 가지에 연결할 수 있다.\n\n![RabbitMQ](rabbitmq.png)\n\n결제 서비스는 교환소에 메세지를 보낸다. 교환은 바인딩이라는 연결을 통해 큐에 연결되고, 이러한 바인딩은 바인딩 키로 참조된다. 그런 다음 재고 서비스가 큐를 구독한다. AMQP, RabbitMQ는 여기서 메세지 브로커의 역할을 한다. 이 메세지 모델의 가장 큰 장점 중 하나는 메세지가 시스템을 통해 다양한 유형으로 유연하게 이동할 수 있다는 점이다.\n\n### 메세지 교환 유형\n\n1. Fan-out exchange\n    \n    Fan-out exchange을 사용하면 결제 메세지가 교환소에 생성되고 교환소는 메세지를 복제해서 알고 있는 모든 큐로 보내거나 직접 교환한다. 직접 교환의 경우, 결제 시 메세지가 생성되고, 해당 메세지는 라우팅 키를 받게 된다. 그리고 라우팅 키와 바운딩 키를 교환하여 정확히 일치하는 경우 해당 서비스로 이동하게 된다.\n    \n2. Topic exchange\n    \n    Topic exchange의 경우, 라우팅 키와 바인딩 키 사이의 부분 일치를 사용한다. 예를 들어 메세지에 `shiop.shoes`라는 라우팅 키가 있고, 바인딩 키가 `ship.any`이면 해당 메세지는 적절한 큐로 라우팅된다.\n    \n3. Hearder exchange\n    \n    Header Exchange를 사용하면 라우팅 키가 완전히 무시되고 메세지는 헤더에 따라 시스템을 통해 이동된다.\n    \n4. Default exchange\n    \n    마지막으로 RabbitMQ에만 고유하는 Default Exchange는 기본 교환인 라우팅 키를 사용해서 만약 이 메세지의 라우팅 키가 `inv`라고 가정하면, 라우팅 키는 큐 자체의 이름과 연결된다. 따라서 큐의 이름이 `inv`인 재고 서비스로 라우팅된다.\n    \n\n### RabbitMQ의 특징\n\n- RabbitMQ의 큰 이점은 클라우드 친화적이라는 것이다. Docker 또는 기타 컨테이너화 소프트웨어에 인스턴스를 배포할 수 있다. 또한 클러스터로 실행될 수 있으므로 내결함성이 있고 가용성이 높으며 처리량이 높다.\n- RabbitMQ는 교차 언어 통신을 할 수 있다. 결제 후 메세지가 생성되면 Javascript로 개발된 재고 서비스와 Python으로 개발된 배송 서비스 모두에서 처리할 수 있다.\n- 보안이 우수하다.(FASL, LDAP, TLS 지원)\n- 메세지 승인을 수행한다. 메세지는 큐에 존재하다가 소비 서비스에게 전달되면 소비자가 브로커에게 메세지 수신을 알릴 때까지 메세지는 큐에 유지된다. 소비 서비스가 메세지가 무사히 수신됐다고 브로커에게 알리면 메세지는 큐에서 제거되기 때문에 시스템에서 메세지가 손실되는 것을 방지할 수 있다.\n- 관리가 용이하다. 브라우저 기반의 관리 UI와 추가적인 CLI 도구가 내장되어 있고, 그뿐만 아니라 오픈소스 커뮤니티에는 많은 플러그인들이 있다. RabbitMQ는 다른 메세지 모델(AMQP 091뿐만 아니라 MQTT, Stomp, AMQP 1.0등)을 지원할 정도로 발전했다.\n\n## 결론\n\nRabbitMQ를 사용하면 컨테이너화된 메세지 브로커를 통해 여러 서비스를 분리할 수 있고 따라서 과부하와 같은 예외적인 상황을 방지할 수 있다.\n\n[참고] [IBM Technology](https://youtu.be/7rkeORD4jSw?si=psWWrn-Gf9bkqtMp)"},{"excerpt":"이진탐색이란 이진 탐색은 업다운 게임과 비슷하다. 찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다. 장점 선형 탐색(배열이나 리스트의 처음부터 하나씩 찾는 방법)은 원소 개수에 비례하는 의 시간복잡도를 갖는데, 이진 탐색은 공간의 크기를 로 줄여나가므로 의 시간복잡도를 갖는다. 조건 이진 탐색을 적용하려면 배…","fields":{"slug":"/binary-search/"},"frontmatter":{"date":"January 10, 2024","title":"🔎 이진탐색과 분할정복","tags":["algorithm"]},"rawMarkdownBody":"\n## 이진탐색이란\n\n이진 탐색은 업다운 게임과 비슷하다. 찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다.\n\n### 장점\n\n선형 탐색*(배열이나 리스트의 처음부터 하나씩 찾는 방법)*은 원소 개수에 비례하는 `O(N)`의 시간복잡도를 갖는데, 이진 탐색은 공간의 크기를 `N/2^x`로 줄여나가므로 `O(logN)`의 시간복잡도를 갖는다.\n\n### 조건\n\n이진 탐색을 적용하려면 배열이나 리스트가 **정렬되어 있어야 한다.**\n\n## 탐색 효율 높이기\n\n### 분할 정복\n\n분할 정복은 업다운 게임과 같이 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어 나가는 방법이다.\n\n1. 범위 찾기\n2. 검사 진행하기\n    \n    [start, end]로 표기된 범위에서 범위 내 속한 원소 개수는 `end - start`\n    \n    탐색 공간이 남아있지 않을 때까지 탐색하려면 `end-start`가 양수일 때 탐색을 계속 반복해야 한다. `end-start > 0` 이므로 `end > start`를 조건으로 하는 반복문으로 탐색을 반복한다.\n    \n    ```java\n    while (end > start) { \n    \t// 범위의 중간 검사\n    }\n    ```\n    \n3. 중간 값 비교하기\n    \n    ```java\n    int mid = (start + end) / 2;\n    int value = arr[mid];\n    ```\n    \n    중간 값을 구했으면 이 값과 찾는 값의 대소를 비교하고, 그에 따라 범위를 적절히 조정한다.\n    \n    ```java\n    if (value == target) {\n    \treturn mid;\n    } else if (value > target) {\n      // Down\n    } else {\n    \t// Up\n    }\n    ```\n    \n    중간값이 찾는 값과 같다면 해당 값의 인덱스인 mid를 반환한다.\n    \n    `value`가 더 크다면 정답은 더 작은 범위에 있으므로 작은 범위에서 탐색을 이어나가고 `value`가 더 작다면 정답은 더 큰 범위에 있으므로 큰 범위에서 탐색을 이어나가야 한다.\n    \n    주의해야 할 점은 `value > target`은 범위를 작은 쪽으로 좁혀야 하고, `value < target`은 범위를 더 큰 쪽으로 좁혀야 한다.\n    \n    ```java\n    if (value == target) {\n    \treturn mid;\n    } else if (value > target) {\n    \tend = mid;\n    } else {\n    \tstart = mid + 1;\n    }\n    ```\n    \n\n전체 코드\n\n```java\nprivate static int binarySearch(int[] arr, int target) {\n\tint strat = 0;\n\tint end = arr.length;\n\n\twhile (end > start) {\n\t\tint mid = (start + end) / 2;\n\t\tint value = arr[mid];\n\n\t\tif (value == target) {\n\t\t\treturn mid;\n\t\t} else if (value > target) {\n\t\t\tend = mid;\n\t\t} else { \n\t\t\tstart = mid + 1;\n\t\t}\n\t}\n\n\treturn -1;\n}\n```\n\n### 정렬 기준 정하기\n\n> 이진 탐색을 진행하려면 배열이 정렬되어 있어야 하고, 대부분의 경우 우리가 직접 데이터를 정렬해주어야 한다.\n\n1. 정렬방식 선택하기\n    \n    이진 탐색을 위해서는 중간값과 정답의 대소를 명확히 구분할 수 있어야 하고, 대소 비교를 하여 정답이 속한 더 작은 범위를 정확히 파악할 수 있어야 한다. 예를 들어, 모든 자릿수의 합이 9인 숫자를 찾는데 오름차순으로 정렬하고 이진 탐색을 적용할 수는 없다.\n    \n    따라서 이진 탐색을 적용하려면 문제에서 요구하는 조건을 정확히 파악하고, 이에 따른 대소 비교를 구현하여 데이터를 정렬한 후 진행해야 한다.\n    \n\n1. 정렬 규칙 찾기\n    \n    이진 탐색 문제의 대부분은 배열이나 리스트를 주고 원소를 찾기보다는 큰 범위의 정답 후보 중 문제 조건에 맞는 정답을 찾아낼 때가 많다. 이때는 문제에서 요구하는 조건의 검사 경과가 정답 후보의 값에 따라 정렬된 상태가 맞는지 확인해 보아야 한다.\n    \n    이진 탐색은 정확한 값을 찾는 데도 사용되지만, 정답 조건을 만족하는 값 중 가장 큰 값 또는 가장 작은 값을 찾는 데에도 많이 이용된다.\n    \n    정답 조건을 만족하는 값 중 가장 큰 값이나 가장 작은 값을 쉽게 찾으려면 범위 좁히기, 범위 표기법 등을 고민해야 한다.\n    \n\n## 자바의 이진탐색 메서드\n\n자바에서는 배열과 리스트에 적용할 수 있는 이진 탐색 메서드를 제공한다.\n\n```java\nArrays.binarySearch() // 배열\nCollections.binarySearch() // 리스트\n```\n\n**단, 탐색 대상 배열과 리스트는 항상 정렬된 상태여야 한다.**\n\n따라서 배열이나 리스트가 정렬되어 있다고 가정할 수 없다면 `Arrays.sort()`나 `Collections.sort()` 메서드로 배열이나 리스트를 정렬한 후 이진 탐색을 진행해야 한다.\n\n```java\nint[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};\nList<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);\\\n\nint arrayIndex = Arrays.binarySearch(array, 8);\nint listIndex = Collections.binarySearch(list, 8);\n\nSystem.out.println(arrayIndex); // 4\nSystem.out.println(listIndex); // 4\n```\n\n위 코드에서 숫자 `8`의 인덱스를 찾기 위해 `Arrays.binarySearch()`와 `Collections.binarySearch()` 메서드로 이진 탐색을 진행하면 해당 원소의 인덱스인 `4`를 반환한다.\n\n만약 찾고자 하는 값이 없다면 어떤 값을 반환할까?\n\n```java\nint[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};\nList<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);\\\n\nint arrayIndex = Arrays.binarySearch(array, 11);\nint listIndex = Collections.binarySearch(list, 11);\n\nSystem.out.println(arrayIndex); // -7\nSystem.out.println(listIndex); // -7\n```\n\n위 예시처럼 없는 원소를 검색하면 음수가 반환되는데. 이 값을 이용하면 검색하려는 원소가 배열이나 리스트에서 어느 위치에 들어가야 하는지 구할 수 있다. **음수 반환값을 양수로 변환하고 1을 빼면 원소가 들어갈 위치가 된다.**\n\n이진 탐색 메서드는 직접 이진 탐색을 구현하지 않아도 된다는 점에서는 매우 유용하다. 정렬된 배열이나 리스트에서 하나의 원소를 찾아야 할 때 강력한 효율성을 보여준다.\n\n\n[참고] 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편"},{"excerpt":"객체지향이란 객체끼리는 서로 공존하는 관계 현실세계에서는 단방향으로 접근 객체지향의 세계에서는 양방향으로 접근(요청 ↔️ 응답) 객체지향 프로그래밍 책임주도설계 객체는 책임을 나눠갖도록 설계해야 한다. 책임주도설계 사람(객체)의 책임: 주유 행동, 가속 요청 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답 주유소(객체)의 책임: 사람으로…","fields":{"slug":"/oop/"},"frontmatter":{"date":"November 30, 2023","title":"🐟 객체는 붕어빵이 아닙니다","tags":["oop"]},"rawMarkdownBody":"\n## 객체지향이란\n\n> 객체끼리는 서로 **공존**하는 관계\n\n* 현실세계에서는 **단방향**으로 접근\n```\n사람 ➡️ 자동차: 단지 도구의 역할\n```\n* 객체지향의 세계에서는 **양방향**으로 접근(**요청 ↔️ 응답**)\n```\n사람 ➡️ 자동차: 엑셀 밟기 요청\n자동차 ➡️ 사람: 가속 응답(기름 소모)\n```\n\n## 객체지향 프로그래밍\n### 책임주도설계\n\n> 객체는 **책임**을 나눠갖도록 설계해야 한다.\n\n![책임주도설계](https://velog.velcdn.com/images/1998/post/058a8fdc-8139-491c-9ca4-43b773476ebe/image.png)\n\n* 사람(객체)의 책임: 주유 행동, 가속 요청\n* 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답\n* 주유소(객체)의 책임: 사람으로부터 주유 요청 시 응답\n\n**즉, 책임주도 설계란 각 객체에게 책임을 부여해서 적절하게 상호작용할 수 있도록 설계하는 것.**\n\n\n### 역할과 구현\n\n>💡 자동차 객체를 버스에 맞춰 구현했는데 트럭이 필요하다면?\n\n**역할(큰 틀)을 중심으로 구현**\n자동차(역할) > 굴러감(책임) > 승용차, 트럭, 버스(구현)\n\n```\n승용차, 트럭, 버스의 공통적인 역할: 엑셀, 전진, 후진, 기름…\n```\n\n**추후에 제한사항이 생길 수 있으므로 공통적인 역할 먼저, 세부적인 건 나중에 구현**\n원하는 기능만을 통해서 자율성을 가질 수 있도록 객체에게 맞는 책임을 잘 부여해야 함.\n잘 만들어진 객체지향은 신뢰할 수 있음.\n\n### 객체지향 프로그래밍의 4가지 특징\n**1. 추상화**\n\n**2. 캡슐화**\n* 한 부분이 망가져도 전체적인 서비스에는 영향이 없게끔 결합도는 낮게 설계해야 한다.\n\n**3. 상속**\n\n**4. 다형성**\n* 메서드 오버라이딩: 상위 → 하위 재정의\n* 메서드 오버로딩: 같은 이름의 메서드 → 상황에 따라 다른 기능\n\n### 객체지향 설계원칙, SOLID\n**1. 단일 책임 원칙(SRP, Single Responsibility Principle)**\n* 하나의 클래스는 하나의 책임만을 가져야 한다.\n\n**2. 개방-폐쇄 원칙(OCP, Open-closed Principle)**\n* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.\n* 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.\n\n**3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)**\n* 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.\n* 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입의 프로그램은 정상 작동해야 한다.\n\n**4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)**\n* 하나의 인터페이스보다 여러 개의 인터페이스로 분리하는 것이 좋다.\n* 인터페이스는 사용자(클라이언트)를 기준으로 분리해야 한다.\n\n**5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)**\n* 추상화가 아닌 구체화에 의존해서는 안된다.\n* 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.\n* 저수준 모듈의 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.\n"},{"excerpt":"다이나믹 프로그래밍이란? 다이나믹 프로그래밍(Dynamic Programming, DP)이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다. 일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다. 📜 피보나치 수열과 분할 정복 피보나치…","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"date":"November 27, 2023","title":"🔥 다이나믹하게 프로그래밍해보자","tags":["algorithm"]},"rawMarkdownBody":"\n## 다이나믹 프로그래밍이란?\n\n> **다이나믹 프로그래밍(Dynamic Programming, DP)**이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.\n\n일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다.\n\n## 📜 피보나치 수열과 분할 정복\n\n피보나치 수열은 **특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합**을 구해야 한다.\n\n> 피보나치 수열 점화식: `D[i] = D[i-1] + D[i-2]`\n\n피보나치 수열의 초기 값은 `1` 로 고정되므로 위 점화식에 적용하면 `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...` 와 같이 나아갈 수 있다.\n만약 단순 분할 정복 기법을 이용해 피보나치 수열을 푼다면 어떻게 될까?\n\n![출처: https://blog.naver.com/ndb796/221233570962](https://velog.velcdn.com/images/1998/post/1392ab01-7f62-4f5b-87e5-30a623405193/image.png)\n\n단순 분할 정복으로 피보나치 수열의 15번째 값인 `D[15]` 를 구하려면 `D[14]` 와 `D[13]` 을 계산해야 하고, `D[14]` 를 구하려면 `D[13]` 과 `D[12]` 를 계산해야 한다.\n이렇게 단순한 분할 정복 기법을 사용하면 이미 수행한 계산를 또 반복적으로 수행하기 때문에 **굉장히!** 비효율적이게 된다.\n\n아래는 단순하게 피보나치 수열을 구하는 과정을 JAVA로 구현한 코드이다.\n\n```java\npublic class Main{\n    static int fibo(int x){\n        if(x == 1) return 1;\n        if(x == 2) return 1;\n        return fibo(x-1) + fibo(x-2);\n    }\n    \n    public static void main(String[] args){\n        System.out.println(fibo(10));\n    }\n}\n```\n\n위와 같이 `fybo` 메서드(함수)에 `10` 을 넣으면 피보나치 수열의 10번째 값인 `55` 가 잘 출력된다. **만약 `fybo` 메서드에 `50` 을 넣으면 어떻게 될까?**\n.\n.\n.\n_아마 우주가 멸망할 때까지 CPU가 달궈지고 결국엔 실행되지 않을 것이다..._😮\n\n이는 사실 당연한 결과로, 피보나치 수열이 1개만 증가해도 **계산량은 2배로 늘어난다.** 위와 같은 방법으로 피보나치 수열의 50번째 값을 구하려면 2의 50제곱 즉, 1,000,000,000,000,000개가 넘는 계산량을 컴퓨터가 처리해야 한다는 것이다.\n\n## 🔥 DP의 등장\n\n다이나믹 프로그래밍은 다음의 두 가정 하에 사용할 수 있다.\n\n> 1. 큰 문제를 작은 문제로 나눌 수 있다.\n> 2. 작은 문제에서 구한 정답이 그 문제를 포함하는 큰 문제에서도 동일하다.\n\n쉽게 말해, 크고 어려운 문제를 잘게 나누어 해결한 뒤에 전체의 답을 구하는 방법이다. 다만 이 과정에서 분할 정복과 다른 점은 **메모이제이션(Memoization)**이 사용된다는 것이다. <u>이미 계산한 결과는 배열에 저장함으로써</u> 나중에 동일한 계산을 해야 할 때 배열에서 꺼내오기만 하면 된다.\n\n### 📝 메모이제이션\n> **메모이제이션(Memoization)**이란 동일한 계산을 반복해야 할 때 <u>이미 계산한 결과를 메모리(배열)에 저장</u>해 두었다가 필요할 때 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다.\n\n다이나믹 프로그래밍의 메모이제이션 기법을 활용하면 우주멸망을 막을 수 있다(?)\n\n```java\npublic class Main{\n    static int[] d = new int[100];\n\n    static int fibo(int x){\n        if(x == 1) return 1;\n        if(x == 2) return 1;\n        if(d[x] != 0) return d[x];\n        return d[x] = fibo(x-1) + fibo(x-2);\n    }\n    \n    public static void main(String[] args){\n        System.out.println(fibo(30));\n    }\n}\n```\n\n위의 코드는 다이나믹 프로그래밍의 메모이제이션 기법을 활용해 작성한 JAVA 코드이다.\n\n이미 계산된 결과는 배열 `d` 에 저장되기 때문에 한 번 구한 값을 다시 계산하는 일은 없으므로 **순식간에!** 피보나치 수열의 30번째 값이 구해지는 것을 볼 수 있다.(50번째 값은 매우 크기 때문에 오버플로우가 발생하여 음수값이 나온다. 알고 싶다면 `int` 타입 대신 `long` 타입을 사용하자)\n\n## 마무리\n[백준 1463번](https://www.acmicpc.net/problem/1463)을 다이나믹하게 풀어보아요\n### ref\n* <a href=\"https://www.google.com/\" target=\"_blank\">[이것이 코딩테스트다] 저자, 나동빈님 블로그</a>"},{"excerpt":"더러운 코드도 돌아는 간다. 하지만 코드가 깨끗하지 못하면 개발 조직은 기어간다. 매년 지저분한 코드로 수많은 시간과 상당한 자원이 낭비된다. 그래야 할 이유가 없다. 로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 코드를 읽어야 한다. 아주 많은 코드를. 그리고 코드를 읽으면서 그 코드의 무엇이 옳은지, 그른지 생각도 해야 한다. 좀 더 중요하게…","fields":{"slug":"/clean-code/"},"frontmatter":{"date":"July 10, 2023","title":"🔎 클린코드 훑어보기","tags":["clean-code"]},"rawMarkdownBody":"\n더러운 코드도 돌아는 간다. 하지만 코드가 깨끗하지 못하면 개발 조직은 기어간다. 매년 지저분한 코드로 수많은 시간과 상당한 자원이 낭비된다. 그래야 할 이유가 없다. 로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 코드를 읽어야 한다. 아주 많은 코드를. 그리고 코드를 읽으면서 그 코드의 무엇이 옳은지, 그른지 생각도 해야 한다. 좀 더 중요하게는 전문가로서 자신이 지니는 가치와 장인으로서 자기 작품(프로그램)에 대한 헌신을 돌아보게 된다. 코드를 읽고, 짜고 정리하는 과정에서 우리가 생각하는 방식을 묘사한 지식 기반을 얻는다.\n\n## 1. 의도를 분명히 밝혀라\n\n변수의 존재 이유, 기능, 사용법 등이 변수, 함수, 클래스명에 드러나야 한다. 의미를 함축하거나 독자가 사전지식을 갖고 있다고 가정하지 말자.\n\n## 2. 그릇된 정보를 피하라\n\n중의적으로 해석될 수 있는 이름을 지양하고 개발자에게는 특수한 의미를 가지는 단어를 변수명에 붙이지 말자. 또한 비슷해 보이는 명명에 주의하자\n\n## 3. 의미 있게 구분하라\n\n말이 안되는 단어, 숫자(a1, a2..)로 구분하는 것을 피하고 클래스 이름에 info, data와 같은 불용어를 붙이지 말자.\n\n## 4. 발음하기 쉬운 이름을 사용하라\n\n## 5. 검색하기 쉬운 이름을 사용하라\n\n상수는 static final과 같이 정의해서 사용하자. 변수 이름의 길이는 변수의 범위에 비례해서 길어진다.\n\n## 6. 자신의 기억력을 자랑하지 마라\n\n독자가 한번 더 생각해 변환해야 할 만한 변수명을 쓰지 말자. 똑똑한 프로그래머와 전문가 프로그래머를 나누는 기준은 **명료함**이다.\n\n## 7. 클래스 이름에 대해\n\n동사 대신 명사 혹은 명사구를 사용하고 Manager, Processor, Data, Info와 같은 단어는 피하자.\n\n## 8. 메서드 이름\n\n동사 혹은 동사구를 사용하고 접근자, 변경자, 조건자는 get, set, is로 시작하자. 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고, 해당 생성자를 private로 선언하자.\n\n## 9. 기발한 이름은 피하라\n\n특정 문화에서만 사용되는 재미있는 이름보다 의도를 분명히 표현하는 이름을 사용하자.\n\n## 10. 한 개념에 한 단어를 사용하라\n\n추상적인 개념 하나에 단어 하나를 사용하자\n\n## 11. 해법 영역(Solution Domain) 용어를 사용하자\n\n개발자라면 당연히 알고 있을 JobQueue, AccountVisitor 등을 사용하지 않을 이유가 없다. 전산용어, 알고리즘 이름, 패턴 이름, 수학적 용어 등은 피하자.\n\n## 12. 문제 영역(Problem Domain) 용어를 사용하자\n\n적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하자.\n\n## 13. 의미 있는 맥락을 추가하라\n\n클래스, 함수, namespace 등으로 감싸서 맥락을 표현하라. 그래도 불분명하다면 접두어를 사용하자."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}