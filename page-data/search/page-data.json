{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"이진탐색이란 이진 탐색은 업다운 게임과 비슷하다. 찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다. 장점 선형 탐색(배열이나 리스트의 처음부터 하나씩 찾는 방법)은 원소 개수에 비례하는 의 시간복잡도를 갖는데, 이진 탐색은 공간의 크기를 로 줄여나가므로 의 시간복잡도를 갖는다. 조건 이진 탐색을 적용하려면 배…","fields":{"slug":"/binary-search/"},"frontmatter":{"date":"January 10, 2024","title":"🔎 이진탐색과 분할정복","tags":["algorithm"]},"rawMarkdownBody":"\r\n## 이진탐색이란\r\n\r\n이진 탐색은 업다운 게임과 비슷하다. 찾고자 하는 정답이 포함된 범위 중 가운데를 검사하고, 정답과 비교하여 절반의 범위를 제외한다.\r\n\r\n### 장점\r\n\r\n선형 탐색*(배열이나 리스트의 처음부터 하나씩 찾는 방법)*은 원소 개수에 비례하는 `O(N)`의 시간복잡도를 갖는데, 이진 탐색은 공간의 크기를 `N/2^x`로 줄여나가므로 `O(logN)`의 시간복잡도를 갖는다.\r\n\r\n### 조건\r\n\r\n이진 탐색을 적용하려면 배열이나 리스트가 **정렬되어 있어야 한다.**\r\n\r\n## 탐색 효율 높이기\r\n\r\n### 분할 정복\r\n\r\n분할 정복은 업다운 게임과 같이 탐색 공간을 특정 기준에 따라 나누고, 나눈 각 탐색 공간에서 탐색을 이어 나가는 방법이다.\r\n\r\n1. 범위 찾기\r\n2. 검사 진행하기\r\n    \r\n    [start, end]로 표기된 범위에서 범위 내 속한 원소 개수는 `end - start`\r\n    \r\n    탐색 공간이 남아있지 않을 때까지 탐색하려면 `end-start`가 양수일 때 탐색을 계속 반복해야 한다. `end-start > 0` 이므로 `end > start`를 조건으로 하는 반복문으로 탐색을 반복한다.\r\n    \r\n    ```java\r\n    while (end > start) { \r\n    \t// 범위의 중간 검사\r\n    }\r\n    ```\r\n    \r\n3. 중간 값 비교하기\r\n    \r\n    ```java\r\n    int mid = (start + end) / 2;\r\n    int value = arr[mid];\r\n    ```\r\n    \r\n    중간 값을 구했으면 이 값과 찾는 값의 대소를 비교하고, 그에 따라 범위를 적절히 조정한다.\r\n    \r\n    ```java\r\n    if (value == target) {\r\n    \treturn mid;\r\n    } else if (value > target) {\r\n      // Down\r\n    } else {\r\n    \t// Up\r\n    }\r\n    ```\r\n    \r\n    중간값이 찾는 값과 같다면 해당 값의 인덱스인 mid를 반환한다.\r\n    \r\n    `value`가 더 크다면 정답은 더 작은 범위에 있으므로 작은 범위에서 탐색을 이어나가고 `value`가 더 작다면 정답은 더 큰 범위에 있으므로 큰 범위에서 탐색을 이어나가야 한다.\r\n    \r\n    주의해야 할 점은 `value > target`은 범위를 작은 쪽으로 좁혀야 하고, `value < target`은 범위를 더 큰 쪽으로 좁혀야 한다.\r\n    \r\n    ```java\r\n    if (value == target) {\r\n    \treturn mid;\r\n    } else if (value > target) {\r\n    \tend = mid;\r\n    } else {\r\n    \tstart = mid + 1;\r\n    }\r\n    ```\r\n    \r\n\r\n전체 코드\r\n\r\n```java\r\nprivate static int binarySearch(int[] arr, int target) {\r\n\tint strat = 0;\r\n\tint end = arr.length;\r\n\r\n\twhile (end > start) {\r\n\t\tint mid = (start + end) / 2;\r\n\t\tint value = arr[mid];\r\n\r\n\t\tif (value == target) {\r\n\t\t\treturn mid;\r\n\t\t} else if (value > target) {\r\n\t\t\tend = mid;\r\n\t\t} else { \r\n\t\t\tstart = mid + 1;\r\n\t\t}\r\n\t}\r\n\r\n\treturn -1;\r\n}\r\n```\r\n\r\n### 정렬 기준 정하기\r\n\r\n> 이진 탐색을 진행하려면 배열이 정렬되어 있어야 하고, 대부분의 경우 우리가 직접 데이터를 정렬해주어야 한다.\r\n\r\n1. 정렬방식 선택하기\r\n    \r\n    이진 탐색을 위해서는 중간값과 정답의 대소를 명확히 구분할 수 있어야 하고, 대소 비교를 하여 정답이 속한 더 작은 범위를 정확히 파악할 수 있어야 한다. 예를 들어, 모든 자릿수의 합이 9인 숫자를 찾는데 오름차순으로 정렬하고 이진 탐색을 적용할 수는 없다.\r\n    \r\n    따라서 이진 탐색을 적용하려면 문제에서 요구하는 조건을 정확히 파악하고, 이에 따른 대소 비교를 구현하여 데이터를 정렬한 후 진행해야 한다.\r\n    \r\n\r\n1. 정렬 규칙 찾기\r\n    \r\n    이진 탐색 문제의 대부분은 배열이나 리스트를 주고 원소를 찾기보다는 큰 범위의 정답 후보 중 문제 조건에 맞는 정답을 찾아낼 때가 많다. 이때는 문제에서 요구하는 조건의 검사 경과가 정답 후보의 값에 따라 정렬된 상태가 맞는지 확인해 보아야 한다.\r\n    \r\n    이진 탐색은 정확한 값을 찾는 데도 사용되지만, 정답 조건을 만족하는 값 중 가장 큰 값 또는 가장 작은 값을 찾는 데에도 많이 이용된다.\r\n    \r\n    정답 조건을 만족하는 값 중 가장 큰 값이나 가장 작은 값을 쉽게 찾으려면 범위 좁히기, 범위 표기법 등을 고민해야 한다.\r\n    \r\n\r\n## 자바의 이진탐색 메서드\r\n\r\n자바에서는 배열과 리스트에 적용할 수 있는 이진 탐색 메서드를 제공한다.\r\n\r\n```java\r\nArrays.binarySearch() // 배열\r\nCollections.binarySearch() // 리스트\r\n```\r\n\r\n**단, 탐색 대상 배열과 리스트는 항상 정렬된 상태여야 한다.**\r\n\r\n따라서 배열이나 리스트가 정렬되어 있다고 가정할 수 없다면 `Arrays.sort()`나 `Collections.sort()` 메서드로 배열이나 리스트를 정렬한 후 이진 탐색을 진행해야 한다.\r\n\r\n```java\r\nint[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};\r\nList<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);\\\r\n\r\nint arrayIndex = Arrays.binarySearch(array, 8);\r\nint listIndex = Collections.binarySearch(list, 8);\r\n\r\nSystem.out.println(arrayIndex); // 4\r\nSystem.out.println(listIndex); // 4\r\n```\r\n\r\n위 코드에서 숫자 `8`의 인덱스를 찾기 위해 `Arrays.binarySearch()`와 `Collections.binarySearch()` 메서드로 이진 탐색을 진행하면 해당 원소의 인덱스인 `4`를 반환한다.\r\n\r\n만약 찾고자 하는 값이 없다면 어떤 값을 반환할까?\r\n\r\n```java\r\nint[] array = new int[] {1, 4, 6, 7, 8, 10, 13, 17};\r\nList<Integer> list = List.of(1, 4, 6, 7, 8, 10, 13, 17);\\\r\n\r\nint arrayIndex = Arrays.binarySearch(array, 11);\r\nint listIndex = Collections.binarySearch(list, 11);\r\n\r\nSystem.out.println(arrayIndex); // -7\r\nSystem.out.println(listIndex); // -7\r\n```\r\n\r\n위 예시처럼 없는 원소를 검색하면 음수가 반환되는데. 이 값을 이용하면 검색하려는 원소가 배열이나 리스트에서 어느 위치에 들어가야 하는지 구할 수 있다. **음수 반환값을 양수로 변환하고 1을 빼면 원소가 들어갈 위치가 된다.**\r\n\r\n이진 탐색 메서드는 직접 이진 탐색을 구현하지 않아도 된다는 점에서는 매우 유용하다. 정렬된 배열이나 리스트에서 하나의 원소를 찾아야 할 때 강력한 효율성을 보여준다.\r\n\r\n\r\n[참고] 프로그래머스 코딩 테스트 문제 풀이 전략: 자바편"},{"excerpt":"객체지향이란 객체끼리는 서로 공존하는 관계 현실세계에서는 단방향으로 접근 객체지향의 세계에서는 양방향으로 접근(요청 ↔️ 응답) 객체지향 프로그래밍 책임주도설계 객체는 책임을 나눠갖도록 설계해야 한다. 책임주도설계 사람(객체)의 책임: 주유 행동, 가속 요청 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답 주유소(객체)의 책임: 사람으로…","fields":{"slug":"/oop/"},"frontmatter":{"date":"November 30, 2023","title":"🐟 객체는 붕어빵이 아닙니다","tags":["oop"]},"rawMarkdownBody":"\r\n## 객체지향이란\r\n\r\n> 객체끼리는 서로 **공존**하는 관계\r\n\r\n* 현실세계에서는 **단방향**으로 접근\r\n```\r\n사람 ➡️ 자동차: 단지 도구의 역할\r\n```\r\n* 객체지향의 세계에서는 **양방향**으로 접근(**요청 ↔️ 응답**)\r\n```\r\n사람 ➡️ 자동차: 엑셀 밟기 요청\r\n자동차 ➡️ 사람: 가속 응답(기름 소모)\r\n```\r\n\r\n## 객체지향 프로그래밍\r\n### 책임주도설계\r\n\r\n> 객체는 **책임**을 나눠갖도록 설계해야 한다.\r\n\r\n![책임주도설계](https://velog.velcdn.com/images/1998/post/058a8fdc-8139-491c-9ca4-43b773476ebe/image.png)\r\n\r\n* 사람(객체)의 책임: 주유 행동, 가속 요청\r\n* 자동차(객체)의 책임: 주유 요청, 사람으로부터 가속 요청 시 응답\r\n* 주유소(객체)의 책임: 사람으로부터 주유 요청 시 응답\r\n\r\n**즉, 책임주도 설계란 각 객체에게 책임을 부여해서 적절하게 상호작용할 수 있도록 설계하는 것.**\r\n\r\n\r\n### 역할과 구현\r\n\r\n>💡 자동차 객체를 버스에 맞춰 구현했는데 트럭이 필요하다면?\r\n\r\n**역할(큰 틀)을 중심으로 구현**\r\n자동차(역할) > 굴러감(책임) > 승용차, 트럭, 버스(구현)\r\n\r\n```\r\n승용차, 트럭, 버스의 공통적인 역할: 엑셀, 전진, 후진, 기름…\r\n```\r\n\r\n**추후에 제한사항이 생길 수 있으므로 공통적인 역할 먼저, 세부적인 건 나중에 구현**\r\n원하는 기능만을 통해서 자율성을 가질 수 있도록 객체에게 맞는 책임을 잘 부여해야 함.\r\n잘 만들어진 객체지향은 신뢰할 수 있음.\r\n\r\n### 객체지향 프로그래밍의 4가지 특징\r\n**1. 추상화**\r\n\r\n**2. 캡슐화**\r\n* 한 부분이 망가져도 전체적인 서비스에는 영향이 없게끔 결합도는 낮게 설계해야 한다.\r\n\r\n**3. 상속**\r\n\r\n**4. 다형성**\r\n* 메서드 오버라이딩: 상위 → 하위 재정의\r\n* 메서드 오버로딩: 같은 이름의 메서드 → 상황에 따라 다른 기능\r\n\r\n### 객체지향 설계원칙, SOLID\r\n**1. 단일 책임 원칙(SRP, Single Responsibility Principle)**\r\n* 하나의 클래스는 하나의 책임만을 가져야 한다.\r\n\r\n**2. 개방-폐쇄 원칙(OCP, Open-closed Principle)**\r\n* 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.\r\n* 기능을 변경하거나 확장할 수 있으면서 기능을 사용하는 코드는 수정하지 않는다.\r\n\r\n**3. 리스코프 치환 원칙(LSP, Liskov Substitution Principle)**\r\n* 객체는 프로그램의 정확성을 깨지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.\r\n* 상위 타입의 객체를 하위 타입의 객체로 치환해도 상위 타입의 프로그램은 정상 작동해야 한다.\r\n\r\n**4. 인터페이스 분리 원칙(ISP, Interface Segregation Principle)**\r\n* 하나의 인터페이스보다 여러 개의 인터페이스로 분리하는 것이 좋다.\r\n* 인터페이스는 사용자(클라이언트)를 기준으로 분리해야 한다.\r\n\r\n**5. 의존관계 역전 원칙(DIP, Dependency Inversion Principle)**\r\n* 추상화가 아닌 구체화에 의존해서는 안된다.\r\n* 고수준 모듈은 저수준 모듈의 구현에 의존해서는 안된다.\r\n* 저수준 모듈의 고수준 모듈에서 정의한 추상 타입에 의존해야 한다.\r\n"},{"excerpt":"다이나믹 프로그래밍이란? 다이나믹 프로그래밍(Dynamic Programming, DP)이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다. 일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다. 📜 피보나치 수열과 분할 정복 피보나치…","fields":{"slug":"/dynamic-programming/"},"frontmatter":{"date":"November 27, 2023","title":"🔥 다이나믹하게 프로그래밍해보자","tags":["algorithm"]},"rawMarkdownBody":"\r\n## 다이나믹 프로그래밍이란?\r\n\r\n> **다이나믹 프로그래밍(Dynamic Programming, DP)**이란 하나의 문제를 단 한 번만 풀도록 하는 알고리즘이다.\r\n\r\n일반적으로 분할 정복 기법은 동일한 문제를 다시 푼다는 단점을 가지고 있다. 단순 분할 정복으로 풀게 되면 심각한 비효율성을 낳는 대표적인 예시로는 피보나치 수열이 있다.\r\n\r\n## 📜 피보나치 수열과 분할 정복\r\n\r\n피보나치 수열은 **특정한 숫자를 구하기 위해 그 앞에 있는 숫자와 두 칸 앞에 있는 숫자의 합**을 구해야 한다.\r\n\r\n> 피보나치 수열 점화식: `D[i] = D[i-1] + D[i-2]`\r\n\r\n피보나치 수열의 초기 값은 `1` 로 고정되므로 위 점화식에 적용하면 `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, ...` 와 같이 나아갈 수 있다.\r\n만약 단순 분할 정복 기법을 이용해 피보나치 수열을 푼다면 어떻게 될까?\r\n\r\n![출처: https://blog.naver.com/ndb796/221233570962](https://velog.velcdn.com/images/1998/post/1392ab01-7f62-4f5b-87e5-30a623405193/image.png)\r\n\r\n단순 분할 정복으로 피보나치 수열의 15번째 값인 `D[15]` 를 구하려면 `D[14]` 와 `D[13]` 을 계산해야 하고, `D[14]` 를 구하려면 `D[13]` 과 `D[12]` 를 계산해야 한다.\r\n이렇게 단순한 분할 정복 기법을 사용하면 이미 수행한 계산를 또 반복적으로 수행하기 때문에 **굉장히!** 비효율적이게 된다.\r\n\r\n아래는 단순하게 피보나치 수열을 구하는 과정을 JAVA로 구현한 코드이다.\r\n\r\n```java\r\npublic class Main{\r\n    static int fibo(int x){\r\n        if(x == 1) return 1;\r\n        if(x == 2) return 1;\r\n        return fibo(x-1) + fibo(x-2);\r\n    }\r\n    \r\n    public static void main(String[] args){\r\n        System.out.println(fibo(10));\r\n    }\r\n}\r\n```\r\n\r\n위와 같이 `fybo` 메서드(함수)에 `10` 을 넣으면 피보나치 수열의 10번째 값인 `55` 가 잘 출력된다. **만약 `fybo` 메서드에 `50` 을 넣으면 어떻게 될까?**\r\n.\r\n.\r\n.\r\n_아마 우주가 멸망할 때까지 CPU가 달궈지고 결국엔 실행되지 않을 것이다..._😮\r\n\r\n이는 사실 당연한 결과로, 피보나치 수열이 1개만 증가해도 **계산량은 2배로 늘어난다.** 위와 같은 방법으로 피보나치 수열의 50번째 값을 구하려면 2의 50제곱 즉, 1,000,000,000,000,000개가 넘는 계산량을 컴퓨터가 처리해야 한다는 것이다.\r\n\r\n## 🔥 DP의 등장\r\n\r\n다이나믹 프로그래밍은 다음의 두 가정 하에 사용할 수 있다.\r\n\r\n> 1. 큰 문제를 작은 문제로 나눌 수 있다.\r\n> 2. 작은 문제에서 구한 정답이 그 문제를 포함하는 큰 문제에서도 동일하다.\r\n\r\n쉽게 말해, 크고 어려운 문제를 잘게 나누어 해결한 뒤에 전체의 답을 구하는 방법이다. 다만 이 과정에서 분할 정복과 다른 점은 **메모이제이션(Memoization)**이 사용된다는 것이다. <u>이미 계산한 결과는 배열에 저장함으로써</u> 나중에 동일한 계산을 해야 할 때 배열에서 꺼내오기만 하면 된다.\r\n\r\n### 📝 메모이제이션\r\n> **메모이제이션(Memoization)**이란 동일한 계산을 반복해야 할 때 <u>이미 계산한 결과를 메모리(배열)에 저장</u>해 두었다가 필요할 때 꺼내 씀으로써 중복 계산을 방지할 수 있게 하는 기법이다.\r\n\r\n다이나믹 프로그래밍의 메모이제이션 기법을 활용하면 우주멸망을 막을 수 있다(?)\r\n\r\n```java\r\npublic class Main{\r\n    static int[] d = new int[100];\r\n\r\n    static int fibo(int x){\r\n        if(x == 1) return 1;\r\n        if(x == 2) return 1;\r\n        if(d[x] != 0) return d[x];\r\n        return d[x] = fibo(x-1) + fibo(x-2);\r\n    }\r\n    \r\n    public static void main(String[] args){\r\n        System.out.println(fibo(30));\r\n    }\r\n}\r\n```\r\n\r\n위의 코드는 다이나믹 프로그래밍의 메모이제이션 기법을 활용해 작성한 JAVA 코드이다.\r\n\r\n이미 계산된 결과는 배열 `d` 에 저장되기 때문에 한 번 구한 값을 다시 계산하는 일은 없으므로 **순식간에!** 피보나치 수열의 30번째 값이 구해지는 것을 볼 수 있다.(50번째 값은 매우 크기 때문에 오버플로우가 발생하여 음수값이 나온다. 알고 싶다면 `int` 타입 대신 `long` 타입을 사용하자)\r\n\r\n## 마무리\r\n[백준 1463번](https://www.acmicpc.net/problem/1463)을 다이나믹하게 풀어보아요\r\n### ref\r\n* <a href=\"https://www.google.com/\" target=\"_blank\">[이것이 코딩테스트다] 저자, 나동빈님 블로그</a>"},{"excerpt":"더러운 코드도 돌아는 간다. 하지만 코드가 깨끗하지 못하면 개발 조직은 기어간다. 매년 지저분한 코드로 수많은 시간과 상당한 자원이 낭비된다. 그래야 할 이유가 없다. 로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 코드를 읽어야 한다. 아주 많은 코드를. 그리고 코드를 읽으면서 그 코드의 무엇이 옳은지, 그른지 생각도 해야 한다. 좀 더 중요하게…","fields":{"slug":"/clean-code/"},"frontmatter":{"date":"July 10, 2023","title":"🔎 클린코드 훑어보기","tags":["clean-code"]},"rawMarkdownBody":"\r\n더러운 코드도 돌아는 간다. 하지만 코드가 깨끗하지 못하면 개발 조직은 기어간다. 매년 지저분한 코드로 수많은 시간과 상당한 자원이 낭비된다. 그래야 할 이유가 없다. 로버트 마틴은 이 책에서 혁명적인 패러다임을 제시한다. 코드를 읽어야 한다. 아주 많은 코드를. 그리고 코드를 읽으면서 그 코드의 무엇이 옳은지, 그른지 생각도 해야 한다. 좀 더 중요하게는 전문가로서 자신이 지니는 가치와 장인으로서 자기 작품(프로그램)에 대한 헌신을 돌아보게 된다. 코드를 읽고, 짜고 정리하는 과정에서 우리가 생각하는 방식을 묘사한 지식 기반을 얻는다.\r\n\r\n## 1. 의도를 분명히 밝혀라\r\n\r\n변수의 존재 이유, 기능, 사용법 등이 변수, 함수, 클래스명에 드러나야 한다. 의미를 함축하거나 독자가 사전지식을 갖고 있다고 가정하지 말자.\r\n\r\n## 2. 그릇된 정보를 피하라\r\n\r\n중의적으로 해석될 수 있는 이름을 지양하고 개발자에게는 특수한 의미를 가지는 단어를 변수명에 붙이지 말자. 또한 비슷해 보이는 명명에 주의하자\r\n\r\n## 3. 의미 있게 구분하라\r\n\r\n말이 안되는 단어, 숫자(a1, a2..)로 구분하는 것을 피하고 클래스 이름에 info, data와 같은 불용어를 붙이지 말자.\r\n\r\n## 4. 발음하기 쉬운 이름을 사용하라\r\n\r\n## 5. 검색하기 쉬운 이름을 사용하라\r\n\r\n상수는 static final과 같이 정의해서 사용하자. 변수 이름의 길이는 변수의 범위에 비례해서 길어진다.\r\n\r\n## 6. 자신의 기억력을 자랑하지 마라\r\n\r\n독자가 한번 더 생각해 변환해야 할 만한 변수명을 쓰지 말자. 똑똑한 프로그래머와 전문가 프로그래머를 나누는 기준은 **명료함**이다.\r\n\r\n## 7. 클래스 이름에 대해\r\n\r\n동사 대신 명사 혹은 명사구를 사용하고 Manager, Processor, Data, Info와 같은 단어는 피하자.\r\n\r\n## 8. 메서드 이름\r\n\r\n동사 혹은 동사구를 사용하고 접근자, 변경자, 조건자는 get, set, is로 시작하자. 생성자를 오버로드할 경우 정적 팩토리 메서드를 사용하고, 해당 생성자를 private로 선언하자.\r\n\r\n## 9. 기발한 이름은 피하라\r\n\r\n특정 문화에서만 사용되는 재미있는 이름보다 의도를 분명히 표현하는 이름을 사용하자.\r\n\r\n## 10. 한 개념에 한 단어를 사용하라\r\n\r\n추상적인 개념 하나에 단어 하나를 사용하자\r\n\r\n## 11. 해법 영역(Solution Domain) 용어를 사용하자\r\n\r\n개발자라면 당연히 알고 있을 JobQueue, AccountVisitor 등을 사용하지 않을 이유가 없다. 전산용어, 알고리즘 이름, 패턴 이름, 수학적 용어 등은 피하자.\r\n\r\n## 12. 문제 영역(Problem Domain) 용어를 사용하자\r\n\r\n적절한 프로그래머 용어가 없거나 문제 영역과 관련이 깊은 용어의 경우 문제 영역 용어를 사용하자.\r\n\r\n## 13. 의미 있는 맥락을 추가하라\r\n\r\n클래스, 함수, namespace 등으로 감싸서 맥락을 표현하라. 그래도 불분명하다면 접두어를 사용하자."}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}